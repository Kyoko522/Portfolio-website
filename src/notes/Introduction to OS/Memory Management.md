In a uniprogramming system, main memory is divided into two parts: one part for the operating system (resident monitor, kernel) and one part for the program currently being executed. In a multiprogramming system, the “user” part of memory must be further subdivided to accommodate multiple processes. The task of subdivision is carried out dynamically by the operating system and is known as memory management .

Effective memory management is vital in a multiprogramming system. If only a few processes are in memory, then for much of the time all of the processes will be waiting for I/O and the processor will be idle. Thus memory needs to be allocated to ensure a reasonable supply of ready processes to consume available processor time.

We begin this chapter with a look at the requirements that memory management is intended to satisfy. Next, we approach the technology of memory management by looking at a variety of simple schemes that have been used. Our focus is the requirement that a program must be loaded into main memory to be executed. This discussion introduces some of the fundamental principles of memory management.

---

| Term    | Definitions                                                                                                                                                                                                                                                                                           |
| ------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Frame   | A fixed-length block of main memory                                                                                                                                                                                                                                                                   |
| Page    | A fixed-length block of data that resides in secondary memory (such as disk). A page of data may temporarily be copied into a frame of memory                                                                                                                                                         |
| Segment | A variable-length block of data that resides in secondary memory. An entire segment may temporarily be copied into an available region of main memory (segmentation) or the segment may be divided into pages which can be individually copied into a main memory (combined segmentation and paging). |

### Memory Management Requirements 
- Memory management is intended to satisfy the following requirements
1. Relocation 
2. Protection 
3. Sharing 
4. Logical Organization 
5. Physical Organization 

#### Relocation 
In a multiprogramming system, the available main memory is generally shared among a number of processes. Typically, it is not possible for the programmer to know in advance which other programs will be resident in main memory at the time of execution of his or her program. 

In addition, we would like to be able to swap active processes in and out of main memory to maximize processor utilization by providing a large pool of ready processes to execute. 

Once a program is swapped out to disk, it would be quite limiting to specify that when it is next swapped back in, it must be placed in the same main memory region as before. Instead, we may need to relocate the process to a different area of memory.


#### Protection 
Each process should be protected against unwanted interference by other processes, whether accidental or intentional. Thus, programs in other processes should not be able to reference memory locations in a process for reading or writing purposes without permission. In one sense, satisfaction of the relocation requirement increases the difficulty of satisfying the protection requirement. Because the location of a program in main memory is unpredictable, it is impossible to check absolute addresses at compile time to assure protection. Furthermore, most programming languages allow the dynamic calculation of addresses at run time (e.g., by computing an array subscript or a pointer into a data structure). Hence all

memory references generated by a process must be checked at run time to ensure that they refer only to the memory space allocated to that process. Fortunately, we shall see that mechanisms that support relocation also support the protection requirement.

Normally, a user process cannot access any portion of the operating system, neither program nor data. Again, usually a program in one process cannot branch to an instruction in another process. Without special arrangement, a program in one process cannot access the data area of another process. The processor must be able to abort such instructions at the point of execution.

Note that the memory protection requirement must be satisfied by the processor (hardware) rather than the operating system (software). This is because the OS cannot anticipate all of the memory references that a program will make. Even if such anticipation were possible, it would be prohibitively time consuming to screen each program in advance for possible memory-reference violations. Thus, it is only possible to assess the permissibility of a memory reference (data access or branch) at the time of execution of the instruction making the reference. To accomplish this, the processor hardware must have that capability.

#### Sharing 
Any protection mechanism must have the flexibility to allow several processes to access the same portion of main memory. For example, if a number of processes are executing the same program, it is advantageous to allow each process to access the same copy of the program rather than have its own separate copy. Processes that are cooperating on some task may need to share access to the same data structure. The memory management system must therefore allow controlled access to shared areas of memory without compromising essential protection. Again, we will see that the mechanisms used to support relocation support sharing capabilities.

#### Physical Organization 
As we discussed in Section 1.5 , computer memory is organized into at least two levels, referred to as main memory and secondary memory. Main memory provides fast access at relatively high cost. In addition, main memory is volatile; that is, it does not provide permanent storage. Secondary memory is slower and cheaper than main memory and is usually not volatile. Thus secondary memory of large capacity can be provided for long-term storage of programs and data, while a smaller main memory holds programs and data currently in use.

In this two-level scheme, the organization of the flow of information between main and secondary memory is a major system concern. The responsibility for this flow could be assigned to the individual programmer, but this is impractical and undesirable for two reasons:

1. The main memory available for a program plus its data may be insufficient. In

that case, the programmer must engage in a practice known as overlaying , in which the program and data are organized in such a way that various modules can be assigned the same region of memory, with a main program responsible for switching the modules in and out as needed. Even with the aid of compiler tools, overlay programming wastes programmer time.

2. In a multiprogramming environment, the programmer does not know at the time of coding how much space will be available or where that space will be.

It is clear, then, that the task of moving information between the two levels of memory should be a system responsibility. This task is the essence of memory management.


### Memory Partitioning 
- Memory management brings process into a main memory for execution by the processor 
	- involves virtual memory which is
	- based on segmentations and paging, which is 
	- based on simpler partitioning schemes
- Partitioning 
	- used in several variations in some now-obsolete operating system
	- does not involve virtual memory



| Techniques                   | Descriptions                                                                                                                                                                                                                                           | Strengths                                                                                                                   | Weaknesses                                                                                           |
| ---------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- |
| Fixed Partitioning           | Main memory is dicied into a number fo static partiions at system generation time. a process may be loaded into a paration of equal or greater size                                                                                                    | simple to implement; little operating system overhead                                                                       | Ineffiecent use of memory due to internal fragmentation; maximum number of active processes is fixed |
| Dynamic Partitioning         | Partitions are created dynamically so that each process is loedaed into a partioon of ecaclty the sam size as the process                                                                                                                              | no itnernal fratmetnation; more efficient sue of main memoryu                                                               | inefficient use of processor due to the need for compacttion to coutner ecternal framentation        |
| Simple paging                | Main memory is divided inot a number of equal-size frams. each process is dicied into a number of equla-sizem pages of the same length as frames. A process is leoaded bny loading all of its pages inot available, not necessarily contiguous, frames | no external fragmentation                                                                                                   | A small amount of internal fragmetnation                                                             |
| SImple Segmatation           | Each process is dicied inot a number of segments. a process is loaded by laoiding all of its segemtns into dynamic partitions that need not be contuouse                                                                                               | no internal fragmetnation; imporved memory utilization and redueced overhead compared to dynamic partiitioning              | ecxternal fragmentation                                                                              |
| virtual memory paging        | as with simple paging, excpept that it is not necessar to lioad all of the apgeos of a process. Non resdsident pages that are need are brought in later automatically                                                                                  | no excternal fragmentation; higher degree of multiprogramming; larger virtual address space                                 | overhead of complex memory management                                                                |
| Virttual Memory Segmentation | as with simple segmentation, except that it is not necessary to load all fo t5he segments that are needed are brought in later automatically                                                                                                           | no internal fratgmentation, higher degree of multiporgrammingl larger virual address space; -protection and sharing support | overhead of complex memory management                                                                |


### Fixing Partitioning 
Equal-size partitions 
- any process whose size is less than or equal to the partition size can be loaded into an available partition 
- The operating system can swap out a process if all partitions are full and no process is in the Ready or Running state

### Unequal Size Partitioning problems  
- Used unequal size partitions helps lessen 
	- programs up to 16M can be accommodate without overlays 
	- Partitions smaller the 8M allow smaller programs to be accommodated with less internal fragmentation

Disadvantage of fixed partitioning
- A program may be too big to fit into a partition. In this case, the programmer must design the program with the use of overlays so that only a portion of the program need be in main memory at any one time. When a module is needed that is not present, the user’s program must load that module into the program’s partition, overlaying whatever programs or data are there.
- Main memory utilization is extremely inefficient. Any program, no matter how small, occupies an entire partition. In our example, there may be a program whose length is less than 2 Mbytes; yet it occupies an 8-Mbyte partition whenever it is swapped in. This phenomenon, in which there is wasted space internal to a partition due to the fact that the block of data loaded is smaller than the partition, is referred to as internal fragmentation

### Dynamic Partitioning 
- Partitions are of variable  length and number 
- Process is allocated exactly as much memory as it requires 
- This technique was used by IBM's mainframe operating system, OS/MVT
External Fragmentation 
- memory becomes more and more fragmented 
- memory utilization declines 
Compaction 
- technique for overcoming external fragmentation 
- OS shift processes so that they are contiguous 
- free memory is together in one block 
- time consuming and waste CPU time 

### Placement Algorithms 
- Best 
	- choose the block that is closest in size to the request
- First-fit
	- begins to scan memory from the beginning and chooses the first available block that is large enough
- Next-fit 
	- begins to scan memory from the location of the last placement and chooses the next available block that is large enough 

### Buddy System 
- Comprised of fixed and dynamic partitioning schemes 
- Memory blocks are available for size 2^k words, L>=

### Relocation Issues 
- During its lifetime Process P moves in memory 
	- Relocation (swapping)
	- compaction
- Program does memory references, e.g. y=&x
	- x's address change over P's lifetime
- Program can't compile changes over P's lifetime
- Instead a logical address compiled in

### Addresses 
- Logical 
	- reference to a memory location independent of the current assignment of data to memory
- Relative
	- address is expressed as a location relative to some known point (usually the start of the program/process location)
- Physical or Absolute
	- actual location in main memory 

#### Paging 
- Partition memory into equal fixed-size chunks that are relatively small 
- Process is also divided into small fixed-size chunks of the same size 

what is internal and external fragmentation in OS

#### Page Table 
- Maintained by the operating system for each process 
- Contains the frame location for each page in the process 
- Processor must know how to access for the current process 
- Used by processor to produce a physical address
	- Logical address (page number, offset)
	- Physical address (frame number, offset)
![[Pasted image 20240419134255.png]]

### Segmentation
like page but the page but the difference is that the page size were determined as for segmentation they can be any size.
- A program can be subdivided into segments 
	- may vary on length
	- there is a maximum length
- Addressing consists of two parts 
	- segment number 
	- an offset
- Similar to dynamic partitioning 
- Eliminates internal fragmentation 
the segmentation table looks different to a page table since now we need to know the length of that segment and the base (where it starts in memory) each segment is to add the correct offset 

to find the real memory address you need to add the base and offset together 
![[Pasted image 20240419141804.png]]
- the length is only used to check that the address that was calculated is acutally inside of that segmentation 